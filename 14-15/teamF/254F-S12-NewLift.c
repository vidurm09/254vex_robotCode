#pragma config(Sensor, in1,    Jumper,         sensorAnalog)
#pragma config(Sensor, dgtl1,  leftQuad,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  armQuad,        sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  flipQuad,       sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  rightQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, solenoid1,      sensorDigitalOut)
#pragma config(Motor,  port1,           liftd,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           lifte,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontRightMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           backRightMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           frontLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           flipper,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lifta,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           liftb,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          liftc,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Lift: a and b on one side, c and d on the other side
//Can't use 4 and 10 at the same tlime

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define SPROCKET_DIAMETER 1.69 //1.69 inches
#define WHEEL_DIAMETER 4 //4 inches
#define MAX_POWER 127 //Max motor power

#define KPL 20 //Left proportionality constant
#define KDL 10 //Left derivative constant
#define KPR 20 //Right proportionality constant
#define KDR 10 //Right derivative constant
#define KPS 16 //Strafe proportioniality constant
#define KDS 8 //Strafe derivative constant
#define KPA 35 //Arm proportionality constant
#define KDA 11 //Arm derivative constant
#define KPF 6 //Flip proportionality constant
#define KDF 10 //Flip derivative constant

float previousErrorL, previousErrorR, previousErrorA, previousErrorF; //Basic error from last cycle
float currentErrorL, currentErrorR, currentErrorA, currentErrorF; //Basic error from current cycle
float targetL, targetR, targetA,targetF; //Target distances
float pErrorL, pErrorR, pErrorA, pErrorF; //Proportionality errors
float dErrorL, dErrorR, dErrorA, dErrorF; //Derivative errors
float outputL, outputR, outputA, outputF; //Power outputs
bool dEnabled, aEnabled, fEnabled; //Turns PD control on or off
int aCurrentStop, fCurrentStop; //Used to tell if arm/flipper is currently controlled by PD
int autoSelector; //Used to change autonomous for red vs. blue sides
int fCount; //for dErrorF

/* Distance  calculation for drive and lift and strafe:
Receives sensor value from encoder
Divides by 120 to find rotations
Multiplies by circumference to find distance */

float dDistance (float tickNumber) {
	return (tickNumber/180 * WHEEL_DIAMETER * PI);
}

float sDistance (float tickNumber) {
    return dDistance(tickNumber)/sqrt(2);
}

float aDistance (float tickNumber) {
	return (tickNumber/120 * SPROCKET_DIAMETER * PI);
}

float fDistance(float tickNumber) {
	return (tickNumber/180 * 6 * SPROCKET_DIAMETER * PI);
}

//Reset drive PD: set all encoders, targets, errors, and counts to 0
void resetDValues () {
	SensorValue[leftQuad] = 0;
	SensorValue[rightQuad] = 0;
	targetL = 0;
	targetR = 0;
	previousErrorL = 0;
	previousErrorR = 0;
	currentErrorL = 0;
	currentErrorR = 0;
	pErrorL = 0;
	pErrorR = 0;
	dErrorL = 0;
	dErrorR = 0;
	outputL = 0;
	outputR = 0;
}

//Reset arm PD: set target, count, and errors to 0
void resetAValues () {
	targetA = 0;
	previousErrorA = 0;
	currentErrorA = 0;
	pErrorA = 0;
	dErrorA = 0;
	outputA = 0;
}

//Reset flip PD: set target, count, and errors to 0
void resetFValues () {
	targetF = 0;
	previousErrorF = 0;
	currentErrorF = 0;
	pErrorF = 0;
	dErrorF = 0;
	outputF = 0;
	fCount = 0;
}

task drivePD()
{
	while (1) {
		if (dEnabled == true) {
			previousErrorL = currentErrorL;
			previousErrorR = currentErrorR;

			currentErrorL = (targetL - dDistance(SensorValue[leftQuad]));
			pErrorL = KPL * currentErrorL;
			dErrorL = KDL * (currentErrorL - previousErrorL);
			outputL = pErrorL - dErrorL;
			if (abs(outputL) > MAX_POWER) {
				motor[frontLeftMotor] = motor[backLeftMotor] = MAX_POWER * sgn(outputL);
			}
			else {
				motor[frontLeftMotor] = motor[backLeftMotor] = outputL;
			}

			currentErrorR = (targetR - dDistance(SensorValue[rightQuad]));
			pErrorR = KPR * currentErrorR;
			dErrorR = KDR * (currentErrorR - previousErrorR);
			outputR = pErrorR - dErrorR;
			if (abs(outputR) > MAX_POWER) {
				motor[frontRightMotor] = motor[backRightMotor] = MAX_POWER * sgn(outputR);
			}
			else {
				motor[frontRightMotor] = motor[backRightMotor] = outputR;
			}
		}
	}
}

task armPD ()
{
	while	(1){
		if (aEnabled == true){
			previousErrorA = currentErrorA;
			currentErrorA = (targetA - aDistance(SensorValue[armQuad]));
			pErrorA = KPA * currentErrorA;
			dErrorA = KDA * (currentErrorA - previousErrorA);

			outputA = pErrorA - dErrorA;

			if (abs(outputA) > MAX_POWER) {
				motor[lifta] = motor[liftb] = motor[liftc] = motor[liftd] = motor[lifte] = MAX_POWER * sgn(outputA);
			}
			else {
				motor[lifta] = motor[liftb] = motor[liftc] = motor[liftd] = motor[lifte] = outputA;
			}
		}
	}
}

task flipPD
{
		while	(1){
		if (fEnabled == true){
			if (fCount == 4)
		  {
				previousErrorF = currentErrorF;
				fCount = fCount - 4;
		  }
			currentErrorF = (targetF - fDistance(SensorValue[flipQuad]));
			pErrorF = KPF * currentErrorF;
			dErrorF = KDF * (currentErrorF - previousErrorF);

			outputF = pErrorF - dErrorF;

			if (abs(outputF) > MAX_POWER) {
				motor[flipper] = MAX_POWER * sgn(outputF);
			}
			else {
				motor[flipper] = outputF;
			}
			fCount++;
		}
		}
}

void goThere (float left, float right)
{
	resetDValues();
	targetL = left;
	targetR = right;
	wait1Msec(100);
	while (abs(currentErrorL) > 1 && abs(currentErrorR) > 1) wait1Msec(100);
}

void goLift (float distance)
{
	resetAValues();
	targetA = distance;
	wait1Msec(100);
	while (abs(currentErrorA) > 5.5) wait1Msec(100);
}

void flipTo (float distance)
{
  resetFValues();
  targetF = distance;
  wait1Msec(100);
  while(abs(currentErrorF) > 8) wait1Msec(100);
}

void pre_auton()
{
	bStopTasksBetweenModes = true; //If it doesn't work with comp control change to true
}

void strafeFree (float distance)
{
	motor[frontLeftMotor] = motor[backRightMotor] = 127 * sgn(distance);
	motor[frontRightMotor] = motor[backLeftMotor] = -127 * sgn(distance);
	while (abs(sDistance(SensorValue[leftQuad])) < abs(distance) && abs(sDistance(SensorValue[rightQuad])) < abs(distance))
	{
		wait1Msec(50);
	}
	motor[frontLeftMotor] = motor[backRightMotor] = 0;
	motor[frontRightMotor] = motor[backLeftMotor] = 0;
}

void driveFree (float timeLength, float power)
{
		motor[frontLeftMotor] = motor[frontRightMotor] = motor[backLeftMotor] = motor[backRightMotor] = power;
		wait1Msec(timeLength);
		motor[frontLeftMotor] = motor[frontRightMotor] = motor[backLeftMotor] = motor[backRightMotor] = 0;
}

void flipperAuto (int skyriseNumber)
{
		wait1Msec(250);
		SensorValue[solenoid1] = 0;
		wait1Msec(250);
		//Raise above skyrise position
		goLift(7);
		writeDebugStreamLine("Passed");
		flipTo(15);
		goLift((skyriseNumber * 6) + 3);
		//Flip to skyrise side and go down
		flipTo(37);
		goLift(skyriseNumber * 6);
		wait1Msec(250);
		SensorValue[solenoid1] = 1;
		wait1Msec(250);
		//Flip from 0 point in front of robot
		flipTo(0);
		//Lower to dispenser position
		goLift(0);
}

task autonomous (){
	//See skills program for changes to auto
	clearDebugStream();
	writeDebugStreamLine("starting auto");

	startTask(drivePD);
	startTask(armPD);
	startTask(flipPD);
	resetDValues();
	resetAValues();
	resetFValues();
	dEnabled = true;
	aEnabled = true;
	fEnabled = true;

	SensorValue[armQuad] = 0;
	SensorValue[flipQuad] = 0;
	SensorValue[solenoid1] = 0;

	if (SensorValue[Jumper] == 0) autoSelector = 1; //Jumper in for blue
	else autoSelector = -1; //Jumper out for red (value is greater than 0)

	dEnabled = false;
	//Strafe to dispenser with robot facing forwards
	if (autoSelector == 1)
	{
		flipTo(12);
		SensorValue[solenoid1] = 1;
		strafeFree(-9 * autoSelector);
		flipTo(2);
		//Alignment
		driveFree(250, -50);
		motor[frontLeftMotor] = motor[frontRightMotor] = motor[backLeftMotor] = motor[backRightMotor] = 40;
		wait1Msec(300);
		motor[frontLeftMotor] = motor[frontRightMotor] = motor[backLeftMotor] = motor[backRightMotor] = 0;
	}
	else
	{
		//RED SIDE DISTANCES UNTESTED
	  flipTo(15);
	  strafeFree(-15 * autoSelector);
	  driveFree(80, 50);
	  strafeFree(-36.5 * autoSelector);
	  //Alignment
	  driveFree(200, -50);
		flipTo(-2);
	}
	//First three skyrises
	flipperAuto(0);
	/*
	flipperAuto(1);
	flipperAuto(2);
	*/
}

task userAuto ()
{
	//Skyrises 3-6
	flipperAuto(3);
	flipperAuto(4);
	flipperAuto(5);
}

task usercontrol ()
{
	writeDebugStreamLine("user");

	/*
	startTask(userAuto);
	while(vexRT[Btn7U] == 0)
	{
		wait1Msec(50);
		//Driver can abort userauto
	}
	stopTask(userAuto);
	*/

	startTask(drivePD);
	startTask(armPD);
	startTask(flipPD);
	SensorValue[armQuad] = 0;
	SensorValue[flipQuad] = 0;
	SensorValue[solenoid1] = 1;
	resetDValues();
	resetAValues();
	resetFValues();
	dEnabled = false;
	aEnabled = false;
	fEnabled = false;
	aCurrentStop = 0;
	fCurrentStop = 0;

	bool strafing = false; //Prevents strafing/driving from interfering

	int wasForwarding = 1;

	while(1) {
		if (!strafing) {
			motor[frontRightMotor] = motor[backRightMotor] = vexRT[Ch2];
			motor[frontLeftMotor] = motor[backLeftMotor] = vexRT[Ch3];
		}
		//Has not been tested/updated for strafing wheels
		/*
		if (vexRT[Btn7R] == 1){
			dEnabled = true;
			goThere(11, -11); //Right turn
			dEnabled = false;
		}
		if (vexRT[Btn7L] == 1){
			dEnabled = true;
			goThere (-11, 11); //Left turn
			dEnabled = false;
		}
		*/
		if (vexRT[Btn5U] == 1){
			aEnabled = false;
			aCurrentStop = 0;
			wait1Msec(10);
			motor[lifta] = motor[liftb] = motor[liftc] = motor[liftd] = motor[lifte] = 127;
		}
		else if (vexRT[Btn5D] == 1){
			aEnabled = false;
			aCurrentStop = 0;
			wait1Msec(10);
			motor[lifta] = motor[liftb] = motor[liftc] = motor[liftd] = motor[lifte] = -127;
		}
		//Elevator PD for user control
		else if (aCurrentStop == 0) {
			aCurrentStop = 1;
			resetAValues();
			targetA = aDistance(SensorValue[armQuad]);
			aEnabled = true;
		}
		/*
		else {
			motor[lifta] = motor[liftb] = motor[liftc] = motor[liftd] = motor[lifte] = 0;
		}
		*/

		if (vexRT[Btn6U] == 1) {
			fEnabled = false;
			fCurrentStop = 0;
			wait1Msec(10);
			motor[flipper] = 127;
			wasForwarding = 1;
		}
		else if (vexRT[Btn6D] == 1) {
			fEnabled = false;
			fCurrentStop = 0;
			wait1Msec(10);
			motor[flipper] = -127;
			wasForwarding = -1;
		}
		//Flipper PD for user control
		else if (fCurrentStop == 0) {
			fCurrentStop = 1;
			targetF = fDistance(SensorValue[flipQuad]) + 5 * wasForwarding;
			fEnabled = true;
		}

		/*
		else {
			motor[flipper] = 0;
		}
		*/
		if (vexRT[Btn8L] == 1) {
			motor[backLeftMotor] = motor[frontRightMotor] = 127;
			motor[frontLeftMotor] = motor[backRightMotor] = -127;
			strafing = true;
		}
		else if (vexRT[Btn8R] == 1) {
			motor[backLeftMotor] = motor[frontRightMotor] = -127;
			motor[frontLeftMotor] = motor[backRightMotor] = 127;
			strafing = true;
		}
		else {
			motor[backLeftMotor] = motor[frontLeftMotor] = motor[backRightMotor] = motor[frontRightMotor] = 0;
			strafing = false;
		}

		if (vexRT[Btn8D] == 1) {
			SensorValue[solenoid1] = 0; //open
		}

		else if (vexRT[Btn8U] == 1) {
			SensorValue[solenoid1] = 1; //close
		}
	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
