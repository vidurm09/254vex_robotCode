#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in2,    lightL,         sensorLineFollower)
#pragma config(Sensor, in3,    lightR,         sensorLineFollower)
#pragma config(Sensor, in4,    expanderPower,  sensorAnalog)
#pragma config(Sensor, dgtl1,  plungerSolenoid, sensorDigitalOut)
#pragma config(Sensor, dgtl2,  clawSolenoid,   sensorDigitalOut)
#pragma config(Sensor, dgtl3,  liftEncoderL,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftEncoderR,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  driveEncoderL,  sensorNone)
#pragma config(Sensor, dgtl8,  driveEncoderL2, sensorNone)
#pragma config(Sensor, dgtl9,  driveEncoderR,  sensorNone)
#pragma config(Sensor, dgtl10, driveEncoderR2, sensorNone)
#pragma config(Sensor, dgtl11, expanderBattery, sensorDigitalIn)
#pragma config(Motor,  port1,           rbDrive,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           ltArm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rtArm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lmArm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rmArm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lbArm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rbArm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lfDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rfDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          lbDrive,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

// Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   // Main competition background code...do not modify!
//#include "SmartMotorLib.c" // motor library

//														Variables

struct pidValues // workaround for arrays
{
	float target;
	float integralSum;
	float currentDistance;
	float lastDistance;
	float derivative;
}

// Constants
const float driveMod = 0.0349; // encoder conversion ratios to inches
const float liftMod = 0.013157;
const float turnMod = 0.1181; // conversion to degrees
const float skyriseHeightInches = 10; // used in liftToSkyrise()
const float minLiftHeight = -1; // lift caps in inches
const float maxLiftHeight = 70;
const int deadzone = 10;
const int debugRefreshDelay = 200; // delay for robotStatus()

// Pneumatics and Timing Variables
bool clawOpen = false; // at start of match, claw is closed
const int clawDelay = 250; // in milliseconds
bool plungerExtended = true; // at start of match, plunger is extended
const int plungerDelay = 250;

// Calculated Variables
float liftHeightInches = 0; // updated by liftMonitor task
float batteryLevel = (float)nImmediateBatteryLevel / 1000; // in volts
float expanderLevel = (float)SensorValue[expanderPower] / 280;

// PID and Autonomous Variables
struct pidValues lDrivePID; // PID variable 'arrays'
struct pidValues rDrivePID;
struct pidValues autoPID;
float proportionalMod = 5; // modifiers of each section of PID
float integralMod = 0;
float derivativeMod = 0;
int sampleTime = 30; // in milliseconds, amount of delay between PID calculations
bool inAuton;
float outputPID;

//														Functions

void clearTimers() // clear ALL timers
{
	clearTimer(T1); // reserved for claw/plunger timing
	clearTimer(T2); // reserved for drive PID timing
	clearTimer(T3); // reserved for auto PID and lift timing
	clearTimer(T4); // reserved for misc. timing purposes
}

void clearPID(struct pidValues* values) // clear a PID's values
{
	values->target = 0;
	values->integralSum = 0;
	values->currentDistance = 0;
	values->lastDistance = 0;
	values->derivative = 0;
}

float calcDriveEncoder(int direction) // calculates encoder value into inches or degrees of *overall movment* according to direction
{
	if (direction == 1) // if strafing left
		return (-SensorValue[driveEncoderL] + SensorValue[driveEncoderR]) / 2 * driveMod;
	else if (direction == 2) // if driving forward
		return (SensorValue[driveEncoderL] + SensorValue[driveEncoderR]) / 2 * driveMod;
	else if (direction == 3) // if strafing right
		return (SensorValue[driveEncoderL] + -SensorValue[driveEncoderR]) / 2 * driveMod;
	else if (direction == 4) // if driving backward
		return (-SensorValue[driveEncoderL] + -SensorValue[driveEncoderR]) / 2 * driveMod;
	else if (direction == 5) // if turning left
		return (SensorValue[driveEncoderL] + SensorValue[driveEncoderR]) / 2 * turnMod;
	else if (direction == 6) // if turning right
		return (SensorValue[driveEncoderL] + -SensorValue[driveEncoderR]) / 2 * turnMod;
	else
		return 0;
}

float calcPID(float encoder, struct pidValues* values) // calculates PID and updates values
{
	values->integralSum += encoder;

	float output = (values->target-encoder)*proportionalMod +
		(values->integralSum)*integralMod + (encoder-values->lastDistance)/sampleTime*derivativeMod;

	values->lastDistance = values->currentDistance;
	values->currentDistance = encoder;
	values->derivative = (encoder-values->lastDistance)/sampleTime;

	if (output > 127)
		output = 127;
	else if (output < -127)
		output = -127;

	return output;
}

//Reverse lfDrive and rfDrive
void drive(float forback, float turnlr, float strafelr) // drive function with deadzone, driver default: Ch3,Ch1,Ch4
{
	if (abs(turnlr) < deadzone)
		turnlr = 0;
	if (abs(forback) < deadzone)
		forback = 0;
	if (abs(strafelr) < deadzone)
		strafelr = 0;

	motor[lbDrive] = forback+turnlr-strafelr;
	motor[lfDrive] = forback+turnlr+strafelr;
	motor[rbDrive] = forback-turnlr+strafelr;
	motor[rfDrive] = forback-turnlr-strafelr;


}

void autoDrive(float speed, int direction, int time) // drive for set time, inherently inaccurate
{
	if (direction == 1) // if strafing left
	   drive(0,0,-speed);
	else if (direction == 2) // if driving forward
		drive(speed,0,0);
	else if (direction == 3) // if strafing right
		drive(0,0,speed);
	else if (direction == 4) // if driving backward
		drive(-speed,0,0);
	else if (direction == 5) // if turning left
		drive(0,-speed,0);
	else if (direction == 6) // if turning right
		drive(0,speed,0);
	if (time > 0)
	{
		wait1Msec(time);
		drive(0,0,0);
	}
}

void lift(bool up, bool down, int speed) // lift function, driver default: 6U,6D,127
{
	if(up && !down)
		motor[lbArm] = motor[ltArm] = motor[lmArm] = motor[rbArm] = motor[rtArm] = motor[rmArm] = speed;
	else if(!up && down)
		motor[lbArm] = motor[ltArm] = motor[lmArm] = motor[rbArm] = motor[rtArm] = motor[rmArm] = -speed;
	else
		motor[lbArm] = motor[ltArm] = motor[lmArm] = motor[rbArm] = motor[rtArm] = motor[rmArm] = 0;
}

void clawDeploy(bool button) // deploys claw, driver default: 5D
{
	if (time1[T1] > clawDelay)
	{
		if(button && !clawOpen){
			SensorValue[clawSolenoid] = 1;
			clawOpen = true;
			clearTimer(T1);
		}
	   else if(button && clawOpen){
			SensorValue[clawSolenoid] = 0;
			clawOpen = false;
			clearTimer(T1);
		}
	}
}

void plungerDeploy(bool button) // deploys plunger, driver default: 5U
{
	if (time1[T1] > plungerDelay)
	{
		if(button && !plungerExtended){
			SensorValue[plungerSolenoid] = 1;
			plungerExtended = true;
			clearTimer(T1);
		}

		else if(button && plungerExtended){
			SensorValue[plungerSolenoid] = 0;
			plungerExtended = false;
			clearTimer(T1);
		}
	}
}

void driveTo(float distance, int direction, int time) // drive to an arbitary distance, with PID and a time limit
{
	clearTimer(T4);
	clearPID(autoPID);
	autoPID.target = distance;

	while (time1[T4] < time) // stops if there is little movement or time limit is reached
	{
		if (time1[T3] > sampleTime)
		{
			outputPID = calcPID(calcDriveEncoder(direction),autoPID);
			autoDrive(outputPID,direction,0);
			clearTimer(T3);
		}
	}
}

void liftTo(float height, int speed, int time) // lift to an arbitrary height, with a limiting time
{
	clearTimer(T3);
	if (liftHeightInches < height)
	{
		lift(true,false,speed);
		while (liftHeightInches < height)
		{
			if (time1[T3] > time)
			{
				writeDebugStreamLine("time break");
				break;
			}
		}
		if (liftHeightInches >= height)
			writeDebugStreamLine("height break");
	}
	else if (liftHeightInches > height)
	{
		lift(false,true,speed);
		while (liftHeightInches > height)
		{
			if (time1[T3] > time)
			{
				writeDebugStreamLine("time break");
				break;
			}
		}
		if (liftHeightInches <= height)
			writeDebugStreamLine("height break");
	}
	lift(false,false,0);
}

void liftToSkyrise(bool button) // shortcut button for liftTo skyrise, driver default:
{
	if (button)
		liftTo(skyriseHeightInches, 127, 10000);
}

//																		Tasks

task liftMonitor() // refreshes lift height and prevents lift from going over/under bounds
{
	liftHeightInches = (SensorValue[liftEncoderL] + SensorValue[liftEncoderR]) * liftMod / 2;
	if (liftHeightInches > maxLiftHeight)
		liftTo(maxLiftHeight,127,100);
	else if (liftHeightInches < minLiftHeight)
		liftTo(minLiftHeight,127,100);
}

task robotStatus() // prints robot info, including battery voltage and lift height
{
	if (time1[T4] > debugRefreshDelay)
	{
		writeDebugStreamLine("Battery voltage: %f", batteryLevel);
		writeDebugStreamLine("Expander voltage: %f", expanderLevel);
		writeDebugStreamLine("Lift Height: %f", liftHeightInches);
	}
}

task drivePIDLoop() // enables straight driving
{
	if (time1[T2] > sampleTime)
	{
		if (!inAuton) // if not in auton, calculate PID target from joystick
		{
			lDrivePID.target = lDrivePID.currentDistance + vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch4];
			rDrivePID.target = rDrivePID.currentDistance + vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4];
		}

		motor[lfDrive] = calcPID(SensorValue[driveEncoderL]*driveMod,lDrivePID);
		motor[rfDrive] = calcPID(SensorValue[driveEncoderR]*driveMod,rDrivePID);

		clearTimer(T2);
	}
}

//                          	Pre-Autonomous Functions

void pre_auton()
{
  bStopTasksBetweenModes = true;
  clearTimers();
  SensorValue[driveEncoderL] = SensorValue[driveEncoderR] = 0;
}

//                                 Autonomous

void blueSkyrise()
{
	writeDebugStreamLine("blue skyrise");
	liftTo(16,120,5000);
	driveTo(9,3,500);
	liftTo(7.5,120,3000);
	clawDeploy(true);
	liftTo(4.6,115,4000);
	plungerDeploy(true);
	wait1Msec(100);
	liftTo(7.5,120,3000);
	clawDeploy(true);
	liftToSkyrise(true);
}

void redSkyrise()
{
		writeDebugStreamLine("red skyrise");
}

void driveAway()
{
		writeDebugStreamLine("drive away");
		liftTo(16,120,2000);
}

task autonomous()
{
	startTask(liftMonitor);
	if (SensorValue[potentiometer] <= 1000) // potentiometer pointed downwards
		blueSkyrise();
	else if (SensorValue[potentiometer] > 1000 && SensorValue[potentiometer] <= 3000)// potentiometer in the middle
		driveAway();
	else if (SensorValue[potentiometer] >= 3000) // potentiometer pointed upwards
		redSkyrise();
	writeDebugStreamLine("	auto complete");
}

//                                 User Control

task usercontrol()
{
	writeDebugStreamLine("user");
	//startTask(robotStatus);
	while (true)
	{
		startTask(liftMonitor);
	  drive(vexRT[Ch3], vexRT[Ch1], vexRT[Ch4]);
	  lift(vexRT[Btn6U], vexRT[Btn6D], 127);
	  clawDeploy(vexRT[Btn5D]);
	  plungerDeploy(vexRT[Btn5U]);
	  liftToSkyrise(vexRT[Btn8D]);
	  if (vexRT[Btn7D]) {
	  	SensorValue[liftEncoderL] = SensorValue[liftEncoderR] = 0;
	  	stopTask(liftMonitor);
	  }
	}
}
